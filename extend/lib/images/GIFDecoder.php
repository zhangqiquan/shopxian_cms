<?php 

           /**
            * 秀仙系统 shopxian_release/3.0.0
            * ============================================================================
            * * 版权所有 2017-2018 上海秀仙网络科技有限公司，并保留所有权利。
            * 网站地址: http://www.shopxian.com；
            * ----------------------------------------------------------------------------
            * 本软件只能免费使用  不允许对程序代码以任何形式任何目的再发布或者出售。
            * ============================================================================
            * 作者: 张启全 

            * 时间: 2018-03-11 18:25:13
            */
           namespace lib\images;      class GIFDecoder {   var $GIF_TransparentR =  -1;   var $GIF_TransparentG =  -1;   var $GIF_TransparentB =  -1;   var $GIF_TransparentI =   0;     var $GIF_buffer = null;   var $GIF_arrays = Array ( );   var $GIF_delays = Array ( );   var $GIF_dispos = Array ( );   var $GIF_stream = "";   var $GIF_string = "";   var $GIF_bfseek =  0;   var $GIF_anloop =  0;        var $GIF_frames_meta =  Array();     var $GIF_screen = Array ( );   var $GIF_global = Array ( );   var $GIF_sorted;   var $GIF_colorS;   var $GIF_colorC;   var $GIF_colorF;      function __construct ( $GIF_pointer ) {    $this->GIF_stream = $GIF_pointer;      GIFDecoder::GIFGetByte ( 6 );    GIFDecoder::GIFGetByte ( 7 );      $this->GIF_screen = $this->GIF_buffer;    $this->GIF_colorF = $this->GIF_buffer [ 4 ] & 0x80 ? 1 : 0;    $this->GIF_sorted = $this->GIF_buffer [ 4 ] & 0x08 ? 1 : 0;    $this->GIF_colorC = $this->GIF_buffer [ 4 ] & 0x07;    $this->GIF_colorS = 2 << $this->GIF_colorC;      if ( $this->GIF_colorF == 1 ) {     GIFDecoder::GIFGetByte ( 3 * $this->GIF_colorS );     $this->GIF_global = $this->GIF_buffer;    }    for ( $cycle = 1; $cycle; ) {     if ( GIFDecoder::GIFGetByte ( 1 ) ) {      switch ( $this->GIF_buffer [ 0 ] ) {       case 0x21:        GIFDecoder::GIFReadExtensions ( );        break;       case 0x2C:        GIFDecoder::GIFReadDescriptor ( );        break;       case 0x3B:        $cycle = 0;        break;      }     }     else {      $cycle = 0;     }    }   }      function GIFReadExtensions ( ) {    GIFDecoder::GIFGetByte ( 1 );    if ( $this->GIF_buffer [ 0 ] == 0xff ) {     for ( ; ; ) {      GIFDecoder::GIFGetByte ( 1 );      if ( ( $u = $this->GIF_buffer [ 0 ] ) == 0x00 ) {       break;      }      GIFDecoder::GIFGetByte ( $u );      if ( $u == 0x03 ) {       $this->GIF_anloop = ( $this->GIF_buffer [ 1 ] | $this->GIF_buffer [ 2 ] << 8 );      }     }    }    else {     for ( ; ; ) {      GIFDecoder::GIFGetByte ( 1 );      if ( ( $u = $this->GIF_buffer [ 0 ] ) == 0x00 ) {       break;      }      GIFDecoder::GIFGetByte ( $u );      if ( $u == 0x04 ) {       $buf4 = count($this->GIF_buffer) >= 5 ? $this->GIF_buffer [ 4 ] : 0;       if ( $buf4 & 0x80 ) {        $this->GIF_dispos [ ] = ( $this->GIF_buffer [ 0 ] >> 2 ) - 1;       }       else {        $this->GIF_dispos [ ] = ( $this->GIF_buffer [ 0 ] >> 2 ) - 0;       }       $this->GIF_delays [ ] = ( $this->GIF_buffer [ 1 ] | $this->GIF_buffer [ 2 ] << 8 );       if ( $this->GIF_buffer [ 3 ] ) {        $this->GIF_TransparentI = $this->GIF_buffer [ 3 ];       }      }     }    }   }      function GIFReadDescriptor ( ) {    $GIF_screen = Array ( );      GIFDecoder::GIFGetByte ( 9 );           $this->GIF_frames_meta[] = array(     'left'=>$this->GIF_buffer[0] + ($this->GIF_buffer[1] << 8),     'top'=>$this->GIF_buffer[2] + ($this->GIF_buffer[3] << 8),     'width'=>$this->GIF_buffer[4] + ($this->GIF_buffer[5] << 8),     'height'=>$this->GIF_buffer[6] + ($this->GIF_buffer[7] << 8),    );         $GIF_screen = $this->GIF_buffer;    $GIF_colorF = $this->GIF_buffer [ 8 ] & 0x80 ? 1 : 0;    if ( $GIF_colorF ) {     $GIF_code = $this->GIF_buffer [ 8 ] & 0x07;     $GIF_sort = $this->GIF_buffer [ 8 ] & 0x20 ? 1 : 0;    }    else {     $GIF_code = $this->GIF_colorC;     $GIF_sort = $this->GIF_sorted;    }    $GIF_size = 2 << $GIF_code;    $this->GIF_screen [ 4 ] &= 0x70;    $this->GIF_screen [ 4 ] |= 0x80;    $this->GIF_screen [ 4 ] |= $GIF_code;    if ( $GIF_sort ) {     $this->GIF_screen [ 4 ] |= 0x08;    }            if ( $this->GIF_TransparentI ) {     $this->GIF_string = "GIF89a";    }    else {     $this->GIF_string = "GIF87a";    }    GIFDecoder::GIFPutByte ( $this->GIF_screen );    if ( $GIF_colorF == 1 ) {     GIFDecoder::GIFGetByte ( 3 * $GIF_size );     if ( $this->GIF_TransparentI ) {      $this->GIF_TransparentR = $this->GIF_buffer [ 3 * $this->GIF_TransparentI + 0 ];      $this->GIF_TransparentG = $this->GIF_buffer [ 3 * $this->GIF_TransparentI + 1 ];      $this->GIF_TransparentB = $this->GIF_buffer [ 3 * $this->GIF_TransparentI + 2 ];     }     GIFDecoder::GIFPutByte ( $this->GIF_buffer );    }    else {     if ( $this->GIF_TransparentI ) {      $this->GIF_TransparentR = $this->GIF_global [ 3 * $this->GIF_TransparentI + 0 ];      $this->GIF_TransparentG = $this->GIF_global [ 3 * $this->GIF_TransparentI + 1 ];      $this->GIF_TransparentB = $this->GIF_global [ 3 * $this->GIF_TransparentI + 2 ];     }     GIFDecoder::GIFPutByte ( $this->GIF_global );    }    if ( $this->GIF_TransparentI ) {     $this->GIF_string .= "!\xF9\x04\x1\x0\x0". chr ( $this->GIF_TransparentI ) . "\x0";    }    $this->GIF_string .= chr ( 0x2C );    $GIF_screen [ 8 ] &= 0x40;    GIFDecoder::GIFPutByte ( $GIF_screen );    GIFDecoder::GIFGetByte ( 1 );    GIFDecoder::GIFPutByte ( $this->GIF_buffer );    for ( ; ; ) {     GIFDecoder::GIFGetByte ( 1 );     GIFDecoder::GIFPutByte ( $this->GIF_buffer );     if ( ( $u = $this->GIF_buffer [ 0 ] ) == 0x00 ) {      break;     }               $this->GIF_string .= substr($this->GIF_stream, $this->GIF_bfseek, $u);     $this->GIF_bfseek += $u;                 }    $this->GIF_string .= chr ( 0x3B );        $this->GIF_arrays [ ] = $this->GIF_string;   }      function GIFGetByte ( $len ) {    $this->GIF_buffer = new SplFixedArray($len);      $l = strlen ( $this->GIF_stream );    for ( $i = 0; $i < $len; $i++ ) {     if ( $this->GIF_bfseek > $l ) {      $this->GIF_buffer->setSize($i);      return 0;     }     $this->GIF_buffer [$i] = ord ( $this->GIF_stream { $this->GIF_bfseek++ } );    }    return 1;   }      function GIFPutByte ( $bytes ) {    $out = '';    foreach ( $bytes as $byte ) {     $out .= chr($byte);    }    $this->GIF_string .= $out;   }      function GIFGetFrames ( ) {    return ( $this->GIF_arrays );   }      function GIFGetFramesMeta ( ) {    return ( $this->GIF_frames_meta );   }      function GIFGetDelays ( ) {    return ( $this->GIF_delays );   }      function GIFGetLoop ( ) {    return ( $this->GIF_anloop );   }      function GIFGetDisposal ( ) {    return ( $this->GIF_dispos );   }      function GIFGetTransparentR ( ) {    return ( $this->GIF_TransparentR );   }      function GIFGetTransparentG ( ) {    return ( $this->GIF_TransparentG );   }      function GIFGetTransparentB ( ) {    return ( $this->GIF_TransparentB );   }  }  